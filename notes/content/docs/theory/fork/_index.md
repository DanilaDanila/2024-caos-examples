---
weight: 70
title: "fork"
enableEmoji: true
# bookCollapseSection: true
---

# Потоки и процессы

![states](../../../sems/fork/kill-meme.jpg)

Давайте пока забудем про потоки и поговорим только про процессы.


## Процессы

Кажется, что за два месяца (как минимум) вы уже имеете какое-то интуитивное понимание, что такое процесс
и, возможно, даже сможете вспомнить, что уже умеете с ними делать.

Давайте формалуем это понятие.


## Что такое процесс?

Нууууу вот если взять исполняемый файл и запустить - получится процесс.
Более формально это называется **программа в состоянии выполнения**.

В целом определение неплохое - но моё любимое - чуть другое.
**Процесс - единица внимания операционной системы**.
Помимо байткодов, которые где-то как-то исполняются, процесс содержит ещё много полезного.

Помните разговоры про операционные системы?
Что ОСь нужна чтоб распределять ресурсы компьютера?
"В куда" ОСь выделяет эти ресурсы - это и есть процесс.

Если мы хотим у операционки "попросить" 2 гига памяти, чтоб сохранить там массив,
она не сможет просто так их нам выдать.
Ей "в некуда".
Каждый свой ресурс она выделяет конкретному процессу.


## Как посмотреть на процессы?

Можете позапускать `ps` / `top` / `hop`.


## Из чего состоит процесс?

Что вообще нужно хранить, чтоб можно было исполнить программу?
1. Исполняемый код
2. Открытые файловые дескрипторы
3. Сигналы, ожидающие обработки
4. Внутренние данные ядра
5. Состояние процесса
6. Адресное пространство, в которое отображена память или файлы
7. Один или несколько потоков выполнения (*)
8. Прочие сегменты данных


### 1. Исполняемый код

Чтоб что-то исполнять, нам нужно это что-то хранить.
Желательно в оперативной памяти, и с соответствующими правами на чтение + исполнение.

Это 'что-то' - это машинные инструкции (aka op-коды).
Секция - `.text`.


### 2. Открытые файловые дескрипторы

Файловый дескриптор - абстракция внутри операционной системы.
Следить за ресурсами, которые за ними скрываются, - задача операционной системы.


### 3. Сигналы, ожидающие обработки

Процессы могут общаться друг с другом (и с ядром), посылая друг другу сигналы.
Сигналы идейно похожи на _syscall наоборот_ - мы описываем, какие сигналы может
обрабатывать ядро.
Потом, в после получения сигнала, будет вызвана его функция-обработчик.

(подробнее на лекции)


### 4. Внутренние данные ядра


У каждого процесса есть процесс, породивший его, - родительский.
Он же будет ожидать обработку кода возврата.
Получается такая древовидная структура - _дерево процессов_.

У каждого процесса есть его текущее состояние - его тоже надо хранить.

Когда процесс был запущен, от чьего имени он работает, какие ограничения по ресурсам есть, ...
Это всё тоже надо хранить.

Вообще структурка довольно большая - можете посмотреть [по ссылке](https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L778).
Разбирать всю мы не будем, но пару знакомых слов найти постараемся.

(код сильно урезан, чтоб поместиться)
```c
struct task_struct {
    struct thread_info        thread_info;
    unsigned int            __state;

    /* saved state for "spinlock sleepers" */
    unsigned int              saved_state;

    void                      *stack;
    refcount_t                usage;

    /* что-то про приоритеты) */
    int                       prio;
    int                       static_prio;
    int                       normal_prio;
    unsigned int              rt_priority;

    int                       exit_state;
    int                       exit_code;
    int                       exit_signal;

    pid_t                     pid;
    pid_t                     tgid;

    #ifdef CONFIG_STACKPROTECTOR
        /* Canary value for the -fstack-protector GCC feature: */
        unsigned long            stack_canary;
    #endif

    /* Real parent process: */
    struct task_struct __rcu  *real_parent;

    /* Recipient of SIGCHLD, wait4() reports: */
    struct task_struct __rcu  *parent;

    /*
     * Children/sibling form the list of natural children:
     */
    struct list_head          children;
    struct list_head          sibling;
    struct task_struct        *group_leader;
}
```


### 5. Состояние процесса

Вы уже вроде поделали домашки по ассемблеру (я надеюсь).

Вы заметили, как сложно было писать код?
Вам нужно было постоянно думать о других процессах?

Нет))))
Потому что ядро справляется прятоть весь остальной мир от вашей программы)

Хотя вы пишите программу так, будто она будет всегда запущена


### 6. Адресное пространство, в которое отображена память или файлы

Можно отнести к внутренним данным ядра, но давайте отдельно выделим.

`mmap` - интрефейс ядра.
То, что мы навыделяли / наотображали нужно где-то хранить


### 7. Один или несколько потоков выполнения (*)

Про несколько потоков выполнения - наглая ложь (об этом ниже).

Но состояние нашего одного единственного потока надо где-то хранить))
Состояние запущенной программы = стек + регистры.

Есть `*stack` с PUSH_REGS и POP_REGS, а так же костыли с `__state`


### 8. Прочие сегменты данных

`.text`

`.data`

`.rodata`

`.bss`

ну и т.д.

Сегменты "закреплены" за процессом.


## Этапы жизни процесса

![states](../../../sems/fork/states.png)

Каждый процесс находится в определенном состоянии - вот список

- **R (running)** - процесс в состоянии выполнения
- **S (sleeping)** - процесс свободен, ждет наступления какого-либо события (спит), может обрабатывать поступающие сигналы
- **D (disk sleep)** - процесс занят (Uninterruptable sleep) тем, что ждет наступления события) не обрабатывает поступающие сигналы
- **T (stopped)** - процесс остановлен (например через SIGSTOP)
- **t (tracing stop)** - кто-то через ptrace управляет нашим процессом
- **X (dead)** - процесс мертв) такое состояние вы, скорее, всего не увидите (живет мало)
- **Z (zombie)** процесс мертв и ожидает, когда родительский процесс получит код возврата

Пока процесс жив и **running** находится либо в очереди на исполнение, либо исполняется.

Потом, в зависимости от внешних / внутренних действий, может переходить в другие состояния.


## Как создать процесс

Есть системный вызов `pid_t fork(void)` - он создаёт точную копию текущего процесса.

> Окей... а если мне нужно запустить что-то другое?

Тогда есть семейство системных вызовов `exec` - они позволяют подменить в вызывающем процессе
текущую программу на другую.

Примеры были на семинаре - можете глянуть


## А при чем тут процессы?

Если погуглить разницу потоков и процессов, то будет какой-то такой ответ

> ..different **processes** cannot share the same memory space (code, variables, etc)
> whereas different **threads** in the same **process** share the same memory space

Что для Linux немного странно звучит с его COW, правами на страницы и т.д...

Просто тут такое дело...


## В Linux потоков не существует

> данная формулировка происходящего может не совпадать с формулировкой, озвученной на лекции

Разделения на **процесс** и **поток** в Linux - нет.
И то и другое изначально называется task (поэтому и структура `task_struct`).

Их "условно" разделяют на потоки и процессы в зависимости от токо, какие ресурсы они разделяют.

Есть системный вызов `clone` - который позволяет создавать дочерние процессы очень гибко
(запоминать не нужно)
```c
int clone(
    int (*fn)(void *_Nullable),
    void *stack,
    int flags,
    void *_Nullable arg,
    ... 
    /* pid_t *_Nullable parent_tid,
       void *_Nullable tls,
       pid_t *_Nullable child_tid
    */
);
```

Помните структуру `task_struct`?
Под копотом и `clone` и `fork` вызывают одно и то же, но `fork` делает +-deep copy (через COW - так быстрее).
- [вот тут объявляется syscall fork](https://github.com/torvalds/linux/blob/master/kernel/fork.c#L2866)
- [вот тут объявляется syscall clone](https://github.com/torvalds/linux/blob/master/kernel/fork.c#L2895)
- [а вот это они вызывают под капотом](https://github.com/torvalds/linux/blob/master/kernel/fork.c#L2743)
- [вот аргументы для kernel_copy](https://github.com/torvalds/linux/blob/master/include/linux/sched/task.h#L23)


А ещё есть возможность объединять процессы в группы.
Номер группы - `pid` родительского процесса (это `tgid` из структуру `task_struct` выше).
Это позволяет общаться не с одним процессом, а сразу с группой

Стало похоже на классическое разделение?)
Оно старательно подгонялось, чтоб быть похожим на классику)
И, говоря **про ядро**, разграничения не существует


## Как создать поток?

Для работы с потоками есть `pthread_create`, `pthread_join`
