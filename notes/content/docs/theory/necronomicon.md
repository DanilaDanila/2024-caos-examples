---
weight: 2
bookFlatSection: true
title: "Некрономикон"
enableEmoji: true
---

# Некрономикон

Тут содержится список заклинаний, запрещенных к использованию.

{{% details title="чё?..." open=false %}}
Содержание любого "примера" с этой страницы в вашем коде _может_ являеться причиной непрохождения код-ревью
{{% /details %}}

## общие требования к любому коду

- старайтесь писать красиво
    - почти всегда `красиво = кратко`
    - а ещё почти всегда `кратко = читаемо`
- давайте осмысленные имена переменным и функциям
    - желательно без однобуквенных названий (не экономьте буквы! они бесплатны)
    - имена функций - желательно глагол
    - имена переменных - желательно существительное
        - для флагов можно `is_active` (ну типа)
    - общепринятые имена (src / dst / fd / socket / i / ...) - это круто!
- избегайте magic_numbers
    - `those who do not believe in %magic will never find it`, но у нас тут C
        - шутка подготовлена любителями python
- ...

(список будет пополняться)

## define-ы

Просто нет

### константы

Да, иногда хочется вынести константу и написать что-то типо такого

```c
#define PI 3.1415926

int main() {
    // ...
    double V = 4.0 / 3.0 * PI * R * R * R;
    // ...
}
```

Но в C существуют константы!) Они и в ошибках компиляции будут выглядеть нормально)

```c
const double PI = 3.1419526;

int main () {
    // ...
    double V = 4.0 / 3.0 * PI * R * R * R;
    // ...
}
```


Для интов есть enum-ы - используйте их

```c
enum {
    FLAG_1 = 1 << 0,
    FLAG_2 = 1 << 1,
    FLAG_3 = 1 << 2,
    FLAG_4 = 1 << 3,

    BUFFER_SIZE = 512,
};


int main() {
    int flags = FLAG_1 | FLAG_2;

    char buffer[BUFFER_SIZE];
}
```

### макросы

У макросов есть неприятный сайд-эфеект - это подстановка текста.
Конкретно тут `++x` будет выполнен дважды.

```c
#include <stdio.h>

#define MAX(a, b) (((a) >= (b)) ? (a) : (b))

int main() {
    int x = 10;
    int y = 11;

    int max_value = MAX(++x, y);
    printf(
        "x = %d\n"
        "y = %d\n"
        "max_value = %d\n",
        x, y, max_value
    );
}
```

{{% details title="какой будет вывод?" open=false %}}
```bash
$ gcc main.c
$ ./a.aout
x = 12
y = 11
max_value = 12
```
{{% /details %}}

Это неявное поведение - старайтесь избегать неявного


## не дублируйте библиотечные константы

Если вам нужна константа - погуглите!) Возможно она уже определена.
Правильнее будет её переиспользовать, т.к.
- константа с таким именем определена не только у вас))
- некоторые константы (например PATH_MAX) могут отличаться от системы к системе

```c
#include <linux/limits.h>
PATH_MAX // chars in a path name INCLUDING NULL

#include <unistd.h>
STDIN_FILENO
STDOUT_FOLENO
STDERR_FILENO

// ... //
```


## работа с файлами

Курс посвящен работе с ядром, так что используйте интерфейс ядра.

Работа с файлами [должна](https://datatracker.ietf.org/doc/html/rfc2119) происходить через файловые дескрипторы. Код, содержащий `FILE*` код-ревью не пройдет.


## помните про код возврата

Код возврата в случае успеха - `0`

Если программа завершилась с ошибкой - завершайтесь с кодом `!=0`.
Желательно ещё и с разными для разных ошибок

```c
int main(int argc, char **argv) {
    if (argc != 2) {
        return 2;  // код возврата != 0
    }

    // ... //

    if (smth_else_failed) {
        return 3;  // другой код возврата != 0
    }

    // ... //
}
```

## чистите память, закрывайте файлы и т.д.

> Оно все равно почистит память после выхода - зачем мне это делать???

Мы не можем дать вам коммитить в большой продакшн-проект на C - у нас нет такого проекта &#x1f605;

Но мы хотим как-то привить вам хорошие привычки. Считайте, что кто-то внешний и большой (кто желательно не должен падать) вызывает ваш модуль - подчищайте за собой.


## корректно завершайте работу

```c
int main() {
    // ... //

    char *buffer = malloc(BUFFER_SIZE * sizeof(char));

    // ... //

    if (smth_very_wrong) {
        // всё очень и очень плохо
        // надо прям завершать работу - всё ужасно!
        // НАДО ПРИБИТЬ ВЕСЬ ПРОЦЕСС!
        exit(1);  // завершаем работу с кодом возврата != 0
    }

    // ... //

    if (should_exit_earlier) {
        // не ошибка
        // но дальше работать смысла не имеет
        goto free_buffer_and_exit;  // и да, это - goto
    }

    // ... //

    char *another_buffer = malloc(BUFFER_SIZE * sizeof(char));

    // ... //

    free(another_buffer);
    free_buffer_and_exit:
        free(buffer);
    return 0;
}
```

В C `goto` активно применяется для "alarm exit".
{{% details title="а почему не <название-любого-другого-приема>?" open=false %}}
Почему так, а не иначе
1. Так исторически сложилось (потому что - см пункт 2)
2. Попробуйте в C достичь такого же эффекта, но чтоб код при этом
    - остался читаемым
    - не дублировал сам себя

Напрашивается вопрос про C++ - в плюсах для этого существует RAII
{{% /details %}}

Фразу **не используйте goto** вы (наверное) слышали и слышали много от кого. Сейчас, в 21-ом веке лучший аргумент, который вы можете услышать от таких людей, - _ДАЖЕ ДЕЙКСТРА ПИСАЛ ОБ ЭТОМ!_ (это правда - вот статья - [Go To Statement Considered Harmful](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf))

До появления циклов и функций в языках, конструкции вида `if (...) goto label;` были распространены - и это правда было нечитаемое месиво.
Он не первый, кто об этом высказывался. Но никто не пытался **запретить** `goto`.
Посыл был - избежать большого кол-ва меток в программах и тем самым сделать код читаемее.
> The remark about the undesirability of the **go to** statement is far from new (68-ой год статьи кста).
> I remember having read the explicit recommendation to restrict the use of **go to** statement to
> alarm exits, but I have not been able to trace it; presumably, it has been made by C. A. R. Hoare. In [1, Sec. 3.2.1.]
> Wirth and Hoare together make a remark in the same direction in motivationg the case construction:
> (тут имеются в виду управляющие конструкции - циклы / функции / ...)
> "Like the conditional, it mirrors the dynamic structure of a program more clearly than **go to**
> statements and switches, and it eliminates the need for introducing a large number of labels in the
> program."

Короче можете отвечать, что вам лично Дейкстра разрешил использовать `goto` для обработки "alarm exits"

Также, можете использовать `goto` для выхода из вложенных циклов, если их нельзя красиво вынести в отдельную функию.
Эта практика менее распространена, чем "alarm exits", но мало языков позволяют красиво сделать "break from inner loop" (кроме rust, других не помню)

## ассемблер

magic_numbers можно избегать используя `.set` (в x86_64)
