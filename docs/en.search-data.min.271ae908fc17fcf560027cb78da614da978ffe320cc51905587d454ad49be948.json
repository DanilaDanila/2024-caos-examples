[{"id":0,"href":"/2024-caos-examples/docs/theory/devools/bash/","title":"bash","section":"Инструменты разработки","content":" bash # bash # Минутка душнотытерминологии # терминал - (вообще говоря - эмулятор терминала) - окошко, куда вводят команды оболочка aka shell - программа-интерпретатор, которая эти команды исполняет bash - одна из оболочек (установлена в начале почти везде) zsh - ещё одна оболочка (оболочка по умолчанию в macOS) Из чего состоит команда # Будет много команд (привыкайте). В общем виде команда выглядит как-то так\ncmd arg1 arg2 arg3 cmd - имя команды arg1, arg2, \u0026hellip; - аргументы arg0 тоже есть - это имя команды Почти всегда (об этом сильно потом TODO: добавить ссылку) команда - это название программы. Программы доступные для запуска лежат, например, по пути /bin/. Список всех путей можно посмотреть в переменной окружения PATH\necho $PATH Аргументы # Чаще всего вместо простого перечисления агрументов будет что-то такое\ncat --help Тогда --help - флаг\nИногда у флагов есть короткие версии. Чаще всего (если не закончились буквы алфавита), короткая версия - первая буква полной.\npython3 --help python3 -h Иногда с помощью флагов передаются значения\nusermod -a -G docker danila -a - флаг\n-G - краткая версия --groups - именованный аргумент (ну типа) - после него идет строка-значение\nИли даже с использованием знака =\ndd if=/dev/zero of=/tmp/foo.dump bs=1M count=10 Это полезно, т.к. позволяет передавать аргументы в произвольном порядке - это удобнее, чем запоминать порядок. Две команды ниже одинаковы\ndd if=/dev/zero of=/tmp/foo.dump bs=1M count=10 dd bs=1M count=1 of=/tmp/foo.dump if=/dev/zero И две команды ниже тоже одинаковы\npsql -h 127.0.0.1 -p 5432 -U admin db psql -p 5432 -U admin -h 127.0.0.1 db Как узнать, что делает команда # У некоторых программ можно вызвать --help\ncat --help Но флаг не всегда одинаковый\u0026hellip;\nnetcat -help В Unix-like системах есть man-страницы (man-pages). Некоторые команды идут вместе с ними. man-страницы есть для команд, функций из библиотек, системных вызовов, \u0026hellip;\nman cat man cat [danila@archlinux ~] $ man cat CAT(1) User Commands CAT(1) NAME cat - concatenate files and print on the standard output SYNOPSIS cat [OPTION]... [FILE]... DESCRIPTION Concatenate FILE(s) to standard output. With no FILE, or when FILE is -, read standard input. -A, --show-all equivalent to -vET -b, --number-nonblank number nonempty output lines, overrides -n -e equivalent to -vE -E, --show-ends display $ at end of each line -n, --number number all output lines -s, --squeeze-blank suppress repeated empty output lines -t equivalent to -vT -T, --show-tabs display TAB characters as ^I -u (ignored) -v, --show-nonprinting use ^ and M- notation, except for LFD and TAB --help display this help and exit --version output version information and exit EXAMPLES cat f - g Output f\u0026#39;s contents, then standard input, then g\u0026#39;s contents. cat Copy standard input to standard output. AUTHOR Written by Torbjorn Granlund and Richard M. Stallman. REPORTING BUGS GNU coreutils online help: \u0026lt;https://www.gnu.org/software/coreutils/\u0026gt; Report any translation bugs to \u0026lt;https://translationproject.org/team/\u0026gt; COPYRIGHT Copyright © 2024 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. SEE ALSO tac(1) Full documentation \u0026lt;https://www.gnu.org/software/coreutils/cat\u0026gt; or available locally via: info \u0026#39;(coreutils) cat invocation\u0026#39; GNU coreutils 9.5 August 2024 CAT(1) как читать man-страницы Ответ можно посмотреть в man-странице команды man\nУ man есть несколько секций (1-9) в каждой из которых лежат соответствующие страницы. exit - доволно простое имя. Существует такая команда - man 1 exit, системный вызов - man 2 exit, и функция - man 3 exit.\nТак же сама страница поеделена на разделы - NAME, SYNOPSIS, \u0026hellip; (дальше идите читать man)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ man man MAN(1) Manual pager utils MAN(1) NAME man - an interface to the system reference manuals SYNOPSIS man [man options] [[section] page ...] ... man -k [apropos options] regexp ... man -K [man options] [section] term ... man -f [whatis options] page ... man -l [man options] file ... man -w|-W [man options] page ... DESCRIPTION man is the system\u0026#39;s manual pager. Each page argument given to man is normally the name of a program, utility or function. The manual page associated with each of these arguments is then found and dis‐ played. A section, if provided, will direct man to look only in that section of the manual. The default action is to search in all of the available sections following a pre-defined order (see DE‐ FAULTS), and to show only the first page found, even if page exists in several sections. The table below shows the section numbers of the manual followed by the types of pages they contain. 1 Executable programs or shell commands 2 System calls (functions provided by the kernel) 3 Library calls (functions within program libraries) 4 Special files (usually found in /dev) 5 File formats and conventions, e.g. /etc/passwd 6 Games 7 Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7), man-pages(7) 8 System administration commands (usually only for root) 9 Kernel routines [Non standard] A manual page consists of several sections. Conventional section names include NAME, SYNOPSIS, CONFIGURATION, DESCRIPTION, OPTIONS, EXIT STATUS, RETURN VALUE, ERRORS, ENVIRON‐ MENT, FILES, VERSIONS, STANDARDS, NOTES, BUGS, EXAMPLE, AUTHORS, and SEE ALSO. А ещё есть info-страницы. Они содержат больше описания, чем man-страницы\ninfo cat info cat [danila@archlinux ~] $ info cat File: coreutils.info, Node: cat invocation, Next: tac invocation, Up: Output of entire files 3.1 ‘cat’: Concatenate and write files ====================================== ‘cat’ copies each FILE (‘-’ means standard input), or standard input if none are given, to standard output. Synopsis: cat [OPTION] [FILE]... The program accepts the following options. Also see *note Common options::. ‘-A’ ‘--show-all’ Equivalent to ‘-vET’. ‘-b’ ‘--number-nonblank’ Number all nonempty output lines, starting with 1. ‘-e’ Equivalent to ‘-vE’. ‘-E’ ‘--show-ends’ Display a ‘$’ after the end of each line. The ‘\\r\\n’ combination is shown as ‘^M$’. ‘-n’ ‘--number’ Number all output lines, starting with 1. This option is ignored if ‘-b’ is in effect. ‘-s’ ‘--squeeze-blank’ Suppress repeated adjacent blank lines; output just one empty line instead of several. ‘-t’ Equivalent to ‘-vT’. ‘-T’ ‘--show-tabs’ Display TAB characters as ‘^I’. ‘-u’ Ignored; for POSIX compatibility. ‘-v’ ‘--show-nonprinting’ Display control characters except for LFD and TAB using ‘^’ notation and precede characters that have the high bit set with ‘M-’. On systems like MS-DOS that distinguish between text and binary files, ‘cat’ normally reads and writes in binary mode. However, ‘cat’ reads in text mode if one of the options ‘-bensAE’ is used or if ‘cat’ is reading from standard input and standard input is a terminal. Similarly, ‘cat’ writes in text mode if one of the options ‘-bensAE’ is used or if standard output is a terminal. An exit status of zero indicates success, and a nonzero value indicates failure. Examples: # Output f\u0026#39;s contents, then standard input, then g\u0026#39;s contents. cat f - g # Copy standard input to standard output. cat И мой любимый tldr - когда вы помните, что делает команда, но не помните, как её правильно вызвать\ntldr tar tldr tar [danila@archlinux ~] $ tldr tar [05:39:03] Archiving utility. Often combined with a compression method, such as `gzip` or `bzip2`. More information: \u0026lt;https://www.gnu.org/software/tar\u0026gt;. [c]reate an archive and write it to a [f]ile: tar cf path/to/target.tar path/to/file1 path/to/file2 ... [c]reate a g[z]ipped archive and write it to a [f]ile: tar czf path/to/target.tar.gz path/to/file1 path/to/file2 ... [c]reate a g[z]ipped archive from a directory using relative paths: tar czf path/to/target.tar.gz --directory=path/to/directory . E[x]tract a (compressed) archive [f]ile into the current directory [v]erbosely: tar xvf path/to/source.tar[.gz|.bz2|.xz] E[x]tract a (compressed) archive [f]ile into the target directory: tar xf path/to/source.tar[.gz|.bz2|.xz] --directory=path/to/directory [c]reate a compressed archive and write it to a [f]ile, using the file extension to [a]utomatically determine the compression program: tar caf path/to/target.tar.xz path/to/file1 path/to/file2 ... Lis[t] the contents of a tar [f]ile [v]erbosely: tar tvf path/to/source.tar E[x]tract files matching a pattern from an archive [f]ile: tar xf path/to/source.tar --wildcards \u0026#34;*.html\u0026#34; Доллар и решётка # Иногда на сайтах вы будете видеть знаки $ или # перед командами\n# usermod -a -G docker danila или\n$ cat my_log.txt Знак # указывает, что команда должна быть запущена от имени пользователя root (администратор в Unix-системах), $ - от обычного пользователя (без прав администратора).\nВыполнить что-нибудь с правами администратора можно с помощью sudo, поэтому знак # я использовать не буду. Знак $ я постараюсь использовать реже и только чтоб отделить команду от её вывода\n$ echo \u0026#34;hello!\u0026#34; hello! Чем стоит научиться пользоваться сейчас (в начале курса) # Для начала работы в терминале этого +-хватит\ncd ls echo cat nano ИЛИ vim mkdir touch rm rmdir head tail "},{"id":1,"href":"/2024-caos-examples/docs/theory/","title":"Как закрыть курс","section":"Docs","content":" Как закрыть курс # В целом всё просто\nделаете задачки проходите code review защищаете задачки profit Про сдачу домашек появится отдельная инструкция, как только выкатят тестилку.\nTODO: сделать инструкцию\nПро операционку # Я ожидаю, что вы используете какой-нибудь дистрибутив на базе Linux. По ним готов оказывать техподдержку.\nЕсли решили проходить курс с помощью WSL / macOS - за поддержкой в общий чат)\nПро языки # Про Си ничего не будет - я предполагаю, что вы его знаете / способны писать, зная плюсы.\nЯзык ассемблера будет с нуля\nbash надеюсь выучите в процессе 😅\nPython будет, но немного (прям совсем немного)\n"},{"id":2,"href":"/2024-caos-examples/docs/theory/whoami/","title":"whoami","section":"Как закрыть курс","content":" whoami # { \u0026#34;name\u0026#34;: \u0026#34;Данила\u0026#34;, \u0026#34;lastname\u0026#34;: \u0026#34;Манаков\u0026#34;, \u0026#34;education\u0026#34;: \u0026#34;ФИВТ МФТИ\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;1-ый курс магистратура\u0026#34;, \u0026#34;telegram\u0026#34;: \u0026#34;t.me/DanilaManakov\u0026#34;, \u0026#34;communication_policy\u0026#34;: \u0026#34;24 / 7 / 365\u0026#34;, \u0026#34;work-experience\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Яндекс\u0026#34;, \u0026#34;major\u0026#34;: \u0026#34;backend Python / C++\u0026#34;, \u0026#34;is_active\u0026#34;: true, }, { \u0026#34;name\u0026#34;: \u0026#34;Anabar\u0026#34;, \u0026#34;major\u0026#34;: \u0026#34;backend Python\u0026#34;, \u0026#34;is_active\u0026#34;: false, }, { \u0026#34;name\u0026#34;: \u0026#34;Т-Банк (ex. Тинькофф)\u0026#34;, \u0026#34;major\u0026#34;: \u0026#34;Product Analytics \u0026amp; Data Science\u0026#34;, \u0026#34;is_active\u0026#34;: false, } ] } "},{"id":3,"href":"/2024-caos-examples/docs/theory/necronomicon/","title":"Некрономикон","section":"Как закрыть курс","content":" Некрономикон # Тут содержится список заклинаний, запрещенных к использованию.\nчё?... Содержание любого \u0026ldquo;примера\u0026rdquo; с этой страницы в вашем коде может являеться причиной непрохождения код-ревью\nобщие требования к любому коду # старайтесь писать красиво почти всегда красиво = кратко а ещё почти всегда кратко = читаемо давайте осмысленные имена переменным и функциям желательно без однобуквенных названий (не экономьте буквы! они бесплатны) имена функций - желательно глагол имена переменных - желательно существительное для флагов можно is_active (ну типа) общепринятые имена (src / dst / fd / socket / i / \u0026hellip;) - это круто! избегайте magic_numbers those who do not believe in %magic will never find it, но у нас тут C шутка подготовлена любителями python \u0026hellip; (список будет пополняться)\ndefine-ы # Просто нет\nконстанты # Да, иногда хочется вынести константу и написать что-то типо такого\n#define PI 3.1415926 int main() { // ... double V = 4.0 / 3.0 * PI * R * R * R; // ... } Но в C существуют константы!) Они и в ошибках компиляции будут выглядеть нормально)\nconst double PI = 3.1419526; int main () { // ... double V = 4.0 / 3.0 * PI * R * R * R; // ... } Для интов есть enum-ы - используйте их\nenum { FLAG_1 = 1 \u0026lt;\u0026lt; 0, FLAG_2 = 1 \u0026lt;\u0026lt; 1, FLAG_3 = 1 \u0026lt;\u0026lt; 2, FLAG_4 = 1 \u0026lt;\u0026lt; 3, BUFFER_SIZE = 512, }; int main() { int flags = FLAG_1 | FLAG_2; char buffer[BUFFER_SIZE]; } макросы # У макросов есть неприятный сайд-эфеект - это подстановка текста. Конкретно тут ++x будет выполнен дважды.\n#include \u0026lt;stdio.h\u0026gt; #define MAX(a, b) (((a) \u0026gt;= (b)) ? (a) : (b)) int main() { int x = 10; int y = 11; int max_value = MAX(++x, y); printf( \u0026#34;x = %d\\n\u0026#34; \u0026#34;y = %d\\n\u0026#34; \u0026#34;max_value = %d\\n\u0026#34;, x, y, max_value ); } какой будет вывод? $ gcc main.c $ ./a.aout x = 12 y = 11 max_value = 12 Это неявное поведение - старайтесь избегать неявного\nне дублируйте библиотечные константы # Если вам нужна константа - погуглите!) Возможно она уже определена. Правильнее будет её переиспользовать, т.к.\nконстанта с таким именем определена не только у вас)) некоторые константы (например PATH_MAX) могут отличаться от системы к системе #include \u0026lt;linux/limits.h\u0026gt; PATH_MAX // chars in a path name INCLUDING NULL #include \u0026lt;unistd.h\u0026gt; STDIN_FILENO STDOUT_FOLENO STDERR_FILENO // ... // работа с файлами # Курс посвящен работе с ядром, так что используйте интерфейс ядра.\nРабота с файлами должна происходить через файловые дескрипторы. Код, содержащий FILE* код-ревью не пройдет.\nпомните про код возврата # Код возврата в случае успеха - 0\nЕсли программа завершилась с ошибкой - завершайтесь с кодом !=0. Желательно ещё и с разными для разных ошибок\nint main(int argc, char **argv) { if (argc != 2) { return 2; // код возврата != 0 } // ... // if (smth_else_failed) { return 3; // другой код возврата != 0 } // ... // } чистите память, закрывайте файлы и т.д. # Оно все равно почистит память после выхода - зачем мне это делать???\nМы не можем дать вам коммитить в большой продакшн-проект на C - у нас нет такого проекта 😅\nНо мы хотим как-то привить вам хорошие привычки. Считайте, что кто-то внешний и большой (кто желательно не должен падать) вызывает ваш модуль - подчищайте за собой.\nкорректно завершайте работу # int main() { // ... // char *buffer = malloc(BUFFER_SIZE * sizeof(char)); // ... // if (smth_very_wrong) { // всё очень и очень плохо // надо прям завершать работу - всё ужасно! // НАДО ПРИБИТЬ ВЕСЬ ПРОЦЕСС! exit(1); // завершаем работу с кодом возврата != 0 } // ... // if (should_exit_earlier) { // не ошибка // но дальше работать смысла не имеет goto free_buffer_and_exit; // и да, это - goto } // ... // char *another_buffer = malloc(BUFFER_SIZE * sizeof(char)); // ... // free(another_buffer); free_buffer_and_exit: free(buffer); return 0; } В C goto активно применяется для \u0026ldquo;alarm exit\u0026rdquo;.\nа почему не \u0026lt;название-любого-другого-приема\u0026gt;? Почему так, а не иначе\nТак исторически сложилось (потому что - см пункт 2) Попробуйте в C достичь такого же эффекта, но чтоб код при этом остался читаемым не дублировал сам себя Напрашивается вопрос про C++ - в плюсах для этого существует RAII\nФразу не используйте goto вы (наверное) слышали и слышали много от кого. Сейчас, в 21-ом веке лучший аргумент, который вы можете услышать от таких людей, - ДАЖЕ ДЕЙКСТРА ПИСАЛ ОБ ЭТОМ! (это правда - вот статья - Go To Statement Considered Harmful)\nДо появления циклов и функций в языках, конструкции вида if (...) goto label; были распространены - и это правда было нечитаемое месиво. Он не первый, кто об этом высказывался. Но никто не пытался запретить goto. Посыл был - избежать большого кол-ва меток в программах и тем самым сделать код читаемее.\nThe remark about the undesirability of the go to statement is far from new (68-ой год статьи кста). I remember having read the explicit recommendation to restrict the use of go to statement to alarm exits, but I have not been able to trace it; presumably, it has been made by C. A. R. Hoare. In [1, Sec. 3.2.1.] Wirth and Hoare together make a remark in the same direction in motivationg the case construction: (тут имеются в виду управляющие конструкции - циклы / функции / \u0026hellip;) \u0026ldquo;Like the conditional, it mirrors the dynamic structure of a program more clearly than go to statements and switches, and it eliminates the need for introducing a large number of labels in the program.\u0026rdquo;\nКороче можете отвечать, что вам лично Дейкстра разрешил использовать goto для обработки \u0026ldquo;alarm exits\u0026rdquo;\nТакже, можете использовать goto для выхода из вложенных циклов, если их нельзя красиво вынести в отдельную функию. Эта практика менее распространена, чем \u0026ldquo;alarm exits\u0026rdquo;, но мало языков позволяют красиво сделать \u0026ldquo;break from inner loop\u0026rdquo; (кроме rust, других не помню)\nассемблер # magic_numbers можно избегать используя .set (в x86_64)\n"},{"id":4,"href":"/2024-caos-examples/docs/theory/devools/","title":"Инструменты разработки","section":"Как закрыть курс","content":" Инструменты разработки # Перед тем, как нырять в ядро и в ассемблер, было бы неплохо научиться хоть что-то делать) Собирать код, запускать программки, и т.д.\nПоэтому эта часть целиком и полностью посвящена инструментам разработки.\nЗаодно разберем все этапы сборки.\n(тут не очень очевидно - этот файлик все \u0026ndash;\u0026gt; дальше welcome в подстраницы)\n"},{"id":5,"href":"/2024-caos-examples/docs/theory/devools/build/","title":"этапы сборки","section":"Инструменты разработки","content":" Этапы сборки # Будем разбирать, как код на C превращается в ошику компиляции исполняемый файлик.\nВот они слева направо # (Ну только сверху вниз) graph TD; c[Код на C] yac[Снова код на C] asm[Код на ассемблере] op[Машинные инструкции] elf[Исполняемый файл] c --\u003e|Препроцессор| yac yac --\u003e|Компилятор| asm asm --\u003e|Ассемблер| op op --\u003e|Линкер| elf (и да, препроцессор из кода на C делает код на C)\nПочти во всех домашках вы будете просто запускать компилятор gcc, после чего вы получите файл a.out, который уже является исполняемым.\ngcc main.c Сейчас давайте пройдемся явно шаг за шагом на примере простой программы\n#include \u0026lt;stdio.h\u0026gt; void greet(char *name) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } int main(int argc, char **argv) { /* argc - кол-во аргументов, переданых программе при запуске * argv - массив строк из этих аргументов * * Хотим чего-то вида * ``` * $ ./a.out CAOS * Hello, CAOS * ``` * * Тогда должно быть ДВА аргумента (argc == 2) * argv[0] - имя программы * argv[1] - имя, которое надо поприветствовать */ if (argc != 2) { // при неправильном кол-ве аргументов // подсказываем, как правильно пользоваться printf(\u0026#34;Usage:\\n\\t%s name\\n\u0026#34;, argv[0]); return 1; } greet(argv[1]); return 0; } Для начала просто соберём. Через флаг -o можно передать имя выходного файла. a.out - имя по умолчанию\ngcc main.c -o a.out $ ./a.out Usage: ./a.out name $ ./a.out hello world Usage: ./a.out name $ ./a.out danila Hello, danila Препроцессор # Препроцессор - это текстовый процессор (программа для обработки текста). Ну и он может делать только простые текстовые операции - подставить один кусок текста вместо вдругого или удалить кусок текста.\nЧто с его помощью можно делать # В C (да и в C++) команды препроцессора начинаются с символа #. Некоторые из них:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;foo.h\u0026#34; #line 42 \u0026#34;somefile.h\u0026#34; #define PI 3.1415926 #define MAX(a, b) (((a) \u0026gt;= (b)) ? (a) : (b)) #define FOO_H #if 2 == 3 #endif #ifdef FOO_H # endif #ifndef FOO_H #elif BAR_H #else #endif Каждая из этих команд только обрабатывает текст\n#include - подставляет вместо себя содержимое файла если скобки \u0026lt;треугольные\u0026gt;, то поиск файла происходит в стандартных путях (всем у кого видна - соболезную); например в /usr/include/; дополнительные пути можно передать, вызвав gcc с флагом -I gcc main.c -I/path/to/include/dir/ ... если используются \u0026quot;кавычки\u0026quot;, то поиск файла в начале идет в директории, где лежит файл, а потом в стандартных путях #line похож на #include, но он подставляет не весь файл, а конкретную строку #define - определяет макросы; так можно задавать константы и правила подстановки вместо PI (пример выше) во время сборки будет подставлено значение 3.1415926 правило MAX(a, b) будет раскрыто напрямую, а это плохо ещё #define может объявлять пустые константы; например #define FOO_H объявит пустую константу FOO_H (пример, зачем такое нужно - ниже) #if... - с их помощью можно выкидывать куски кода из файла; например #if __linux__ будет верно, только при сборке на linux-дистрибутивах а откуда берутся эти константы? ну там __linux__ и прочие?\nТакие константы идут предопределенными вместе с компилятором (в месте с компилятором идет стандартная библиотека и т.д.)\n#ifdef ABC - проверяет, определена ли константа ABC (#ifndef - проверяет, если константа НЕ определена) #ifdef ABC // этот код подставляется если ABC определена #else // этот код подставляется если ABC НЕ определена #endif // ABC Можно запустить только препроцессор, вызвав gcc с флагом -E (файлик получится большой, поэтому посмотрим только на последние 20 строчек)\nmain.c #include \u0026lt;stdio.h\u0026gt; void greet(char *name) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } int main(int argc, char **argv) { /* argc - кол-во аргументов, переданых программе при запуске * argv - массив строк из этих аргументов * * Хотим чего-то вида * ``` * $ ./a.out CAOS * Hello, CAOS * ``` * * Тогда должно быть ДВА аргумента (argc == 2) * argv[0] - имя программы * argv[1] - имя, которое надо поприветствовать */ if (argc != 2) { // при неправильном кол-ве аргументов // подсказываем, как правильно пользоваться printf(\u0026#34;Usage:\\n\\t%s name\\n\u0026#34;, argv[0]); return 1; } greet(argv[1]); return 0; } $ gcc -E main.c -o main.i $ tail -20 main.i # 2 \u0026#34;main.c\u0026#34; 2 # 3 \u0026#34;main.c\u0026#34; void greet(char *name) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } int main(int argc, char **argv) { # 22 \u0026#34;main.c\u0026#34; if (argc != 2) { printf(\u0026#34;Usage:\\n\\t%s name\\n\u0026#34;, argv[0]); return 1; } greet(argv[1]); return 0; } Там сохранился код на C, и рекурсивно подставилось содержимое инклудов (stdio.h). Код на C - это наша программа, а странные строки вида # 22 \u0026quot;main.c\u0026quot; - отладочная инфа. Когда вы ловите ошибку компиляции - благодаря этим комментариям компилятор показывает вам, где и менно и что именно упало.\nС точки зрения самого языка C, строки, начинающиеся с # - это комментарии\nМотивация # А зачем вообще я могу хотеть удалять куски кода? Я же их так старательно\u0026hellip;\nНу вот пример - есть библиотека small_math.h - в ней вы сами написали свои мат. функции специально для работы с малыми величинами.\n// small_math.h // вычисляет произвудную синуса в точке x // при малых значениях x double small_sin_deriv(double x) { return 1.0; } и вы этот файлик используете в нескольких своих модулях - elliptic_curves.h и my_hash.h\nelliptic_curves.h #include \u0026#34;small_math.h\u0026#34; // ну и тут что-нибудь важное my_hash.h #include \u0026#34;small_math.h\u0026#34; // ну и тут что-нибудь необходимое А потом оба этих файлика вы используете в main.c\nmain.c #include \u0026#34;elliptic_curves.h\u0026#34; #include \u0026#34;my_hash.h\u0026#34; int main() { // ... // } Попробуем собрать и получим\u0026hellip;\n$ gcc main.c In file included from my_hash.h:1, from main.c:2: small_math.h:3:8: error: redefinition of ‘small_sin_deriv’ 3 | double small_sin_deriv(double x) { | ^~~~~~~~~~~~~~~ In file included from elliptic_curves.h:1, from main.c:1: small_math.h:3:8: note: previous definition of ‘small_sin_deriv’ with type ‘double(double)’ 3 | double small_sin_deriv(double x) { | ^~~~~~~~~~~~~~~ ошибку redefinition of ‘small_sin_deriv’.\nЧТо зА фиГня?! - спросите вы\nПеречитайте, как работает #include - отвечу вам я.\nЗапустим с флагом -E и посмотрим 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 $ gcc -E main.c # 0 \u0026#34;main.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;main.c\u0026#34; # 1 \u0026#34;elliptic_curves.h\u0026#34; 1 # 1 \u0026#34;small_math.h\u0026#34; 1 double small_sin_deriv(double x) { return 1.0; } # 2 \u0026#34;elliptic_curves.h\u0026#34; 2 # 2 \u0026#34;main.c\u0026#34; 2 # 1 \u0026#34;my_hash.h\u0026#34; 1 # 1 \u0026#34;small_math.h\u0026#34; 1 double small_sin_deriv(double x) { return 1.0; } # 2 \u0026#34;my_hash.h\u0026#34; 2 # 3 \u0026#34;main.c\u0026#34; 2 int main() { } Как видите функций правда две - одна пришла из elliptic_curves.h, вторая - из my_hash.h. В ошибке ровно это и описано.\nЭту проблему можно решить при помощи макросов - нужно инклудить small_math.h только один раз. В C++ вместо большой конструкции можно просто написать #pragma once\n// small_math.h #ifndef SMALL_MATH_H #define SMALL_MATH_H // вычисляет произвудную синуса в точке x // при малых значениях x double small_sin_deriv(double x) { return 1.0; } #endif // SMALL_MATH_H Принято азывать константы таким образом SMALL_MATH_H - капсом и заменяя точку на _. Старайтесь делать так же))\nТеперь файл будет \u0026ldquo;скопирован\u0026rdquo; только один раз во время сборки\n$ gcc -E main.c # 0 \u0026#34;main.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; # 1 \u0026#34;/usr/include/stdc-predef.h\u0026#34; 1 3 4 # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; 2 # 1 \u0026#34;main.c\u0026#34; # 1 \u0026#34;elliptic_curves.h\u0026#34; 1 \u0026lt;-- вот в этом файле подключается small_math.h # 1 \u0026#34;small_math.h\u0026#34; 1 \u0026lt;-- вот прям вот тут вот ТУТ МНОГО ПУСТОГО МЕСТА ИЗ-ЗА КОММЕНТАРИЕВ double small_sin_deriv(double x) { return 1.0; } # 2 \u0026#34;elliptic_curves.h\u0026#34; 2 # 2 \u0026#34;main.c\u0026#34; 2 # 1 \u0026#34;my_hash.h\u0026#34; 1 \u0026lt;-- а вот тут small_math.h уже не подключается # 3 \u0026#34;main.c\u0026#34; 2 int main() { } И сама сборка пройдет без ошибок\n$ gcc main.c (ошибки нет) Компилятор # У нас есть код на C\u0026hellip; снова!) Компилятор из кода на си делает код на языке ассемблера.\nПосмотрим, что станет с нашим файлом. Запустим с флагом -S (можно передавать main.c, так и main.i). Аргумент -masm=intel укажет на Intel-синтаксис языка ассемблера (TODO: вставить ссылку)\ngcc -S -masm=intel main.c main.c #include \u0026lt;stdio.h\u0026gt; void greet(char *name) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } int main(int argc, char **argv) { /* argc - кол-во аргументов, переданых программе при запуске * argv - массив строк из этих аргументов * * Хотим чего-то вида * ``` * $ ./a.out CAOS * Hello, CAOS * ``` * * Тогда должно быть ДВА аргумента (argc == 2) * argv[0] - имя программы * argv[1] - имя, которое надо поприветствовать */ if (argc != 2) { // при неправильном кол-ве аргументов // подсказываем, как правильно пользоваться printf(\u0026#34;Usage:\\n\\t%s name\\n\u0026#34;, argv[0]); return 1; } greet(argv[1]); return 0; } main.s .file\t\u0026#34;main.c\u0026#34; .intel_syntax noprefix .text .section\t.rodata .LC0: .string\t\u0026#34;Hello, %s\\n\u0026#34; .text .globl\tgreet .type\tgreet, @function greet: .LFB0: .cfi_startproc push\trbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov\trbp, rsp .cfi_def_cfa_register 6 sub\trsp, 16 mov\tQWORD PTR -8[rbp], rdi mov\trax, QWORD PTR -8[rbp] mov\trsi, rax lea\trax, .LC0[rip] mov\trdi, rax mov\teax, 0 call\tprintf@PLT nop leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size\tgreet, .-greet .section\t.rodata .LC1: .string\t\u0026#34;Usage:\\n\\t%s name\\n\u0026#34; .text .globl\tmain .type\tmain, @function main: .LFB1: .cfi_startproc push\trbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov\trbp, rsp .cfi_def_cfa_register 6 sub\trsp, 16 mov\tDWORD PTR -4[rbp], edi mov\tQWORD PTR -16[rbp], rsi cmp\tDWORD PTR -4[rbp], 2 je\t.L3 mov\trax, QWORD PTR -16[rbp] mov\trax, QWORD PTR [rax] mov\trsi, rax lea\trax, .LC1[rip] mov\trdi, rax mov\teax, 0 call\tprintf@PLT mov\teax, 1 jmp\t.L4 .L3: mov\trax, QWORD PTR -16[rbp] add\trax, 8 mov\trax, QWORD PTR [rax] mov\trdi, rax call\tgreet mov\teax, 0 .L4: leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1: .size\tmain, .-main .ident\t\u0026#34;GCC: (GNU) 14.2.1 20240910\u0026#34; .section\t.note.GNU-stack,\u0026#34;\u0026#34;,@progbits Язык ассемблера подробно будет разобран вот тут (TODO: вставить ссылку). Но сейчас угадываются разные куски программы\nфункция greet greet: .LFB0: .cfi_startproc push\trbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov\trbp, rsp .cfi_def_cfa_register 6 sub\trsp, 16 mov\tQWORD PTR -8[rbp], rdi mov\trax, QWORD PTR -8[rbp] mov\trsi, rax lea\trax, .LC0[rip] mov\trdi, rax mov\teax, 0 call\tprintf@PLT nop leave .cfi_def_cfa 7, 8 ret строка Usage 1 2 3 4 5 6 7 8 .LFE0: .size\tgreet, .-greet .section\t.rodata .LC1: .string\t\u0026#34;Usage:\\n\\t%s name\\n\u0026#34; .text .globl\tmain .type\tmain, @function функция main main: .LFB1: .cfi_startproc push\trbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov\trbp, rsp .cfi_def_cfa_register 6 sub\trsp, 16 mov\tDWORD PTR -4[rbp], edi mov\tQWORD PTR -16[rbp], rsi cmp\tDWORD PTR -4[rbp], 2 je\t.L3 mov\trax, QWORD PTR -16[rbp] mov\trax, QWORD PTR [rax] mov\trsi, rax lea\trax, .LC1[rip] mov\trdi, rax mov\teax, 0 call\tprintf@PLT mov\teax, 1 jmp\t.L4 .L3: mov\trax, QWORD PTR -16[rbp] add\trax, 8 mov\trax, QWORD PTR [rax] mov\trdi, rax call\tgreet mov\teax, 0 .L4: leave .cfi_def_cfa 7, 8 ret Ассемблер # С ассемблером небольшая путаница\u0026hellip;\nассемблер - это программа язык ассемблера - это язык Ассемблер переводит код на языке ассемблера в машинные инструкции (op-коды). Теперь пожалуйста не путайте)\nПродолжим издеваться над программой. Запустим компилятор с флагом -c, чтоб на выходе получить объектный файл - тот самый файл с машинными инструкциями - main.o\nmain.c #include \u0026lt;stdio.h\u0026gt; void greet(char *name) { printf(\u0026#34;Hello, %s\\n\u0026#34;, name); } int main(int argc, char **argv) { /* argc - кол-во аргументов, переданых программе при запуске * argv - массив строк из этих аргументов * * Хотим чего-то вида * ``` * $ ./a.out CAOS * Hello, CAOS * ``` * * Тогда должно быть ДВА аргумента (argc == 2) * argv[0] - имя программы * argv[1] - имя, которое надо поприветствовать */ if (argc != 2) { // при неправильном кол-ве аргументов // подсказываем, как правильно пользоваться printf(\u0026#34;Usage:\\n\\t%s name\\n\u0026#34;, argv[0]); return 1; } greet(argv[1]); return 0; } $ gcc -c main.c $ file main.o main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped Команда file читает заголовок файла и печатает информацию о нём. ELF - Executable and Linkable File - формат исполняемых файлов на Unix-системах.\nМожем декомпилировать объектный файл - напечатать машинные инструкции в виде мнемоник на языке ассемблера.\nдекомпилированный код Кодс условно разбит на 3 колонки\nв первой колонке указано смещение относительно начала op-кодов во второй колонке идут те самые op-коды в третьей колонке - декомпилированный код на языке ассемблера (да, снова) Даже не зная язык ассемблера, можно угадать функции greet и main\n$ objdump -d -M intel main.o main.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;greet\u0026gt;: 0:\t55 push rbp 1:\t48 89 e5 mov rbp,rsp 4:\t48 83 ec 10 sub rsp,0x10 8:\t48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi c:\t48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 10:\t48 89 c6 mov rsi,rax 13:\t48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 1a \u0026lt;greet+0x1a\u0026gt; 1a:\t48 89 c7 mov rdi,rax 1d:\tb8 00 00 00 00 mov eax,0x0 22:\te8 00 00 00 00 call 27 \u0026lt;greet+0x27\u0026gt; 27:\t90 nop 28:\tc9 leave 29:\tc3 ret 000000000000002a \u0026lt;main\u0026gt;: 2a:\t55 push rbp 2b:\t48 89 e5 mov rbp,rsp 2e:\t48 83 ec 10 sub rsp,0x10 32:\t89 7d fc mov DWORD PTR [rbp-0x4],edi 35:\t48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 39:\t83 7d fc 02 cmp DWORD PTR [rbp-0x4],0x2 3d:\t74 25 je 64 \u0026lt;main+0x3a\u0026gt; 3f:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 43:\t48 8b 00 mov rax,QWORD PTR [rax] 46:\t48 89 c6 mov rsi,rax 49:\t48 8d 05 00 00 00 00 lea rax,[rip+0x0] # 50 \u0026lt;main+0x26\u0026gt; 50:\t48 89 c7 mov rdi,rax 53:\tb8 00 00 00 00 mov eax,0x0 58:\te8 00 00 00 00 call 5d \u0026lt;main+0x33\u0026gt; 5d:\tb8 01 00 00 00 mov eax,0x1 62:\teb 18 jmp 7c \u0026lt;main+0x52\u0026gt; 64:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 68:\t48 83 c0 08 add rax,0x8 6c:\t48 8b 00 mov rax,QWORD PTR [rax] 6f:\t48 89 c7 mov rdi,rax 72:\te8 00 00 00 00 call 77 \u0026lt;main+0x4d\u0026gt; 77:\tb8 00 00 00 00 mov eax,0x0 7c:\tc9 leave 7d:\tc3 ret Линкер # До этого момента мы занимались сборкой файлов. На вход подавался один файл - на выходе был другой файл (но тоже один!). Но проекты состоят из многих файлов. Да, их можно передать на вход gcc main.c lib1.c lib2.c .... До текущего момента каждый из них собирался независимо - и на данном этапе мы имеем множество .o файлов - main.o, lib1.o, lib2.o \u0026hellip;\nЛинкер занимается тем, что собирает разные .o файли вместе. У каждого .o файла в заголовке есть таблица символов. Пока можно считать, что это словарь (отображение) \\[ ИМЯ\\_ФУНКЦИИ \\rightarrow ЕЁ\\_АДРЕС \\] (под \u0026ldquo;адресом\u0026rdquo; имеется в виду смещение относительно начала секции с op-кодами)\nУ нашего main.o тоже есть таблица символов\n$ objdump -t main.o main.o: file format elf64-x86-64 SYMBOL TABLE: 0000000000000000 l df *ABS*\t0000000000000000 main.c 0000000000000000 l d .text\t0000000000000000 .text 0000000000000000 l d .rodata\t0000000000000000 .rodata 0000000000000000 g F .text\t000000000000002a greet 0000000000000000 *UND*\t0000000000000000 printf 000000000000002a g F .text\t0000000000000054 main Тут снова можно увидеть функции greet и main, и их адреса (третья колонка). Но ещё видна функция printf с адресом 000...0 в секции *UND*. Её реализация находится в стандартной библиотеке.\nУ файлов стандартной библиотеки есть соответствующие таблицы символов (будет функция printf с адресом). Линкер высчитывает адреса функций и собирает все в один файл (о разнице статической и динамической линковке поговорим тут TODO: вставить ссылку на динамические библиотеки).\nМожно запустить линкер и получить на выходе исполняемый файл\ngcc main.o Чем ещё занимается линкер # А если я ничего не использую из стандартной библиотеки? Я могу просто взять и запустить объектный файл? Там ведь уже готовые op-коды\nНу лет +-30 назад (во времена DOS) такой .o файл уже можно было запустить. Программа под DOS имела полный контроль над всем компьютером. Сейчас, когда в операционной системе выполняется несколько программ одновременно, под каждую запускаемую программу (под каждый процесс) необходимо выделить ресурсы - оперативную память (как минимум).\nЛинкер прописывает, какие секции (куски памяти) с какими правами и какого размера нужны программе для работы. Без этой информации операционная система просто не запустит программу.\nА ещё я вам все это время врал # Заметили, что на каждом шаге мы запускали gcc? Так вот на самом деле это не компилятор.\ngcc - Gnu C Compiler - препроцессор и компилятор as - gnu ASsembler - ассемблер ld - the gnu linker - линкер gcc - это Gnu Compiler Collection. Помимо компилятора C там ещё и компилятор fortran например. Но он же умеет запускать и ассемблер с линкером.\nМожете попробовать позапускать линкер самостоятельно, но у него давольно много аргументов. Получится только что-то страшное типа\nld /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/crtn.o /usr/lib/x86_64-linux-gnu/crt1.o -lc main.o -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main_ELF_executable Ну вот зачем вам помнить пути до стандартных библиотек?) Вот gcc и передает их за вас))\nELF файл # Подробно будем разбирать ELF файлы вот тут (TODO: вставить ссылку на дин. библиотеки). Но там ровно такие же op-коды\nop-коды $ objdump -d -M intel a.out a.out: file format elf64-x86-64 Disassembly of section .init: 0000000000001000 \u0026lt;_init\u0026gt;: 1000:\tf3 0f 1e fa endbr64 1004:\t48 83 ec 08 sub rsp,0x8 1008:\t48 8b 05 c1 2f 00 00 mov rax,QWORD PTR [rip+0x2fc1] # 3fd0 \u0026lt;__gmon_start__@Base\u0026gt; 100f:\t48 85 c0 test rax,rax 1012:\t74 02 je 1016 \u0026lt;_init+0x16\u0026gt; 1014:\tff d0 call rax 1016:\t48 83 c4 08 add rsp,0x8 101a:\tc3 ret Disassembly of section .plt: 0000000000001020 \u0026lt;printf@plt-0x10\u0026gt;: 1020:\tff 35 ca 2f 00 00 push QWORD PTR [rip+0x2fca] # 3ff0 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x8\u0026gt; 1026:\tff 25 cc 2f 00 00 jmp QWORD PTR [rip+0x2fcc] # 3ff8 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x10\u0026gt; 102c:\t0f 1f 40 00 nop DWORD PTR [rax+0x0] 0000000000001030 \u0026lt;printf@plt\u0026gt;: 1030:\tff 25 ca 2f 00 00 jmp QWORD PTR [rip+0x2fca] # 4000 \u0026lt;printf@GLIBC_2.2.5\u0026gt; 1036:\t68 00 00 00 00 push 0x0 103b:\te9 e0 ff ff ff jmp 1020 \u0026lt;_init+0x20\u0026gt; Disassembly of section .text: 0000000000001040 \u0026lt;_start\u0026gt;: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor ebp,ebp 1046:\t49 89 d1 mov r9,rdx 1049:\t5e pop rsi 104a:\t48 89 e2 mov rdx,rsp 104d:\t48 83 e4 f0 and rsp,0xfffffffffffffff0 1051:\t50 push rax 1052:\t54 push rsp 1053:\t45 31 c0 xor r8d,r8d 1056:\t31 c9 xor ecx,ecx 1058:\t48 8d 3d 04 01 00 00 lea rdi,[rip+0x104] # 1163 \u0026lt;main\u0026gt; 105f:\tff 15 5b 2f 00 00 call QWORD PTR [rip+0x2f5b] # 3fc0 \u0026lt;__libc_start_main@GLIBC_2.34\u0026gt; 1065:\tf4 hlt 1066:\t66 2e 0f 1f 84 00 00 cs nop WORD PTR [rax+rax*1+0x0] 106d:\t00 00 00 1070:\t48 8d 3d a1 2f 00 00 lea rdi,[rip+0x2fa1] # 4018 \u0026lt;__TMC_END__\u0026gt; 1077:\t48 8d 05 9a 2f 00 00 lea rax,[rip+0x2f9a] # 4018 \u0026lt;__TMC_END__\u0026gt; 107e:\t48 39 f8 cmp rax,rdi 1081:\t74 15 je 1098 \u0026lt;_start+0x58\u0026gt; 1083:\t48 8b 05 3e 2f 00 00 mov rax,QWORD PTR [rip+0x2f3e] # 3fc8 \u0026lt;_ITM_deregisterTMCloneTable@Base\u0026gt; 108a:\t48 85 c0 test rax,rax 108d:\t74 09 je 1098 \u0026lt;_start+0x58\u0026gt; 108f:\tff e0 jmp rax 1091:\t0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 1098:\tc3 ret 1099:\t0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 10a0:\t48 8d 3d 71 2f 00 00 lea rdi,[rip+0x2f71] # 4018 \u0026lt;__TMC_END__\u0026gt; 10a7:\t48 8d 35 6a 2f 00 00 lea rsi,[rip+0x2f6a] # 4018 \u0026lt;__TMC_END__\u0026gt; 10ae:\t48 29 fe sub rsi,rdi 10b1:\t48 89 f0 mov rax,rsi 10b4:\t48 c1 ee 3f shr rsi,0x3f 10b8:\t48 c1 f8 03 sar rax,0x3 10bc:\t48 01 c6 add rsi,rax 10bf:\t48 d1 fe sar rsi,1 10c2:\t74 14 je 10d8 \u0026lt;_start+0x98\u0026gt; 10c4:\t48 8b 05 0d 2f 00 00 mov rax,QWORD PTR [rip+0x2f0d] # 3fd8 \u0026lt;_ITM_registerTMCloneTable@Base\u0026gt; 10cb:\t48 85 c0 test rax,rax 10ce:\t74 08 je 10d8 \u0026lt;_start+0x98\u0026gt; 10d0:\tff e0 jmp rax 10d2:\t66 0f 1f 44 00 00 nop WORD PTR [rax+rax*1+0x0] 10d8:\tc3 ret 10d9:\t0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 10e0:\tf3 0f 1e fa endbr64 10e4:\t80 3d 2d 2f 00 00 00 cmp BYTE PTR [rip+0x2f2d],0x0 # 4018 \u0026lt;__TMC_END__\u0026gt; 10eb:\t75 33 jne 1120 \u0026lt;_start+0xe0\u0026gt; 10ed:\t55 push rbp 10ee:\t48 83 3d ea 2e 00 00 cmp QWORD PTR [rip+0x2eea],0x0 # 3fe0 \u0026lt;__cxa_finalize@GLIBC_2.2.5\u0026gt; 10f5:\t00 10f6:\t48 89 e5 mov rbp,rsp 10f9:\t74 0d je 1108 \u0026lt;_start+0xc8\u0026gt; 10fb:\t48 8b 3d 0e 2f 00 00 mov rdi,QWORD PTR [rip+0x2f0e] # 4010 \u0026lt;__dso_handle\u0026gt; 1102:\tff 15 d8 2e 00 00 call QWORD PTR [rip+0x2ed8] # 3fe0 \u0026lt;__cxa_finalize@GLIBC_2.2.5\u0026gt; 1108:\te8 63 ff ff ff call 1070 \u0026lt;_start+0x30\u0026gt; 110d:\tc6 05 04 2f 00 00 01 mov BYTE PTR [rip+0x2f04],0x1 # 4018 \u0026lt;__TMC_END__\u0026gt; 1114:\t5d pop rbp 1115:\tc3 ret 1116:\t66 2e 0f 1f 84 00 00 cs nop WORD PTR [rax+rax*1+0x0] 111d:\t00 00 00 1120:\tc3 ret 1121:\t66 66 2e 0f 1f 84 00 data16 cs nop WORD PTR [rax+rax*1+0x0] 1128:\t00 00 00 00 112c:\t0f 1f 40 00 nop DWORD PTR [rax+0x0] 1130:\tf3 0f 1e fa endbr64 1134:\te9 67 ff ff ff jmp 10a0 \u0026lt;_start+0x60\u0026gt; 0000000000001139 \u0026lt;greet\u0026gt;: 1139:\t55 push rbp 113a:\t48 89 e5 mov rbp,rsp 113d:\t48 83 ec 10 sub rsp,0x10 1141:\t48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi 1145:\t48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 1149:\t48 89 c6 mov rsi,rax 114c:\t48 8d 05 b1 0e 00 00 lea rax,[rip+0xeb1] # 2004 \u0026lt;_IO_stdin_used+0x4\u0026gt; 1153:\t48 89 c7 mov rdi,rax 1156:\tb8 00 00 00 00 mov eax,0x0 115b:\te8 d0 fe ff ff call 1030 \u0026lt;printf@plt\u0026gt; 1160:\t90 nop 1161:\tc9 leave 1162:\tc3 ret 0000000000001163 \u0026lt;main\u0026gt;: 1163:\t55 push rbp 1164:\t48 89 e5 mov rbp,rsp 1167:\t48 83 ec 10 sub rsp,0x10 116b:\t89 7d fc mov DWORD PTR [rbp-0x4],edi 116e:\t48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 1172:\t83 7d fc 02 cmp DWORD PTR [rbp-0x4],0x2 1176:\t74 25 je 119d \u0026lt;main+0x3a\u0026gt; 1178:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 117c:\t48 8b 00 mov rax,QWORD PTR [rax] 117f:\t48 89 c6 mov rsi,rax 1182:\t48 8d 05 86 0e 00 00 lea rax,[rip+0xe86] # 200f \u0026lt;_IO_stdin_used+0xf\u0026gt; 1189:\t48 89 c7 mov rdi,rax 118c:\tb8 00 00 00 00 mov eax,0x0 1191:\te8 9a fe ff ff call 1030 \u0026lt;printf@plt\u0026gt; 1196:\tb8 01 00 00 00 mov eax,0x1 119b:\teb 18 jmp 11b5 \u0026lt;main+0x52\u0026gt; 119d:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 11a1:\t48 83 c0 08 add rax,0x8 11a5:\t48 8b 00 mov rax,QWORD PTR [rax] 11a8:\t48 89 c7 mov rdi,rax 11ab:\te8 89 ff ff ff call 1139 \u0026lt;greet\u0026gt; 11b0:\tb8 00 00 00 00 mov eax,0x0 11b5:\tc9 leave 11b6:\tc3 ret Disassembly of section .fini: 00000000000011b8 \u0026lt;_fini\u0026gt;: 11b8:\tf3 0f 1e fa endbr64 11bc:\t48 83 ec 08 sub rsp,0x8 11c0:\t48 83 c4 08 add rsp,0x8 11c4:\tc3 ret Но врал вам не только я)) В a.out файле легко находится функция _start\nвот тут _start 30 31 32 33 34 35 36 37 38 39 40 41 Disassembly of section .text: 0000000000001040 \u0026lt;_start\u0026gt;: 1040:\tf3 0f 1e fa endbr64 1044:\t31 ed xor ebp,ebp 1046:\t49 89 d1 mov r9,rdx 1049:\t5e pop rsi 104a:\t48 89 e2 mov rdx,rsp 104d:\t48 83 e4 f0 and rsp,0xfffffffffffffff0 1051:\t50 push rax 1052:\t54 push rsp 1053:\t45 31 c0 xor r8d,r8d С функции _start начинается выполнение программ в Unix-системах. Функция main вызывается стандартной библиотекой, где и объявлена функция _start.\n"},{"id":6,"href":"/2024-caos-examples/docs/theory/devools/debugger/","title":"как ловить ошибки","section":"Инструменты разработки","content":" как ловить ошибки # отладчик # Звучит банально - но попробуйте)\nОн позволяет:\nсмотреть на значения переменных во время исполнения программы построчно исполнять программу ставить breakpoint-ы на определенных строках - это нужно чтоб доходить до проблемного места автоматически Для начала привыкайте во время тестирования собиать программы с флагом -ggdb\ngcc -ggdb main.c -o runmepls Это включит в исполняемый файл runmepls отладочную информацию. Без неё вам придется вглядываться в язык ассемблера, а это не так удобно.\nQt Creator # Понимаю, что не все любят терминал. Это ваш выбор, я не буду его осуждать, хоть он и не правильный Qt - это фреймворк для создания оконных приложений. Qt Creator - IDE для него. Но Qt Creator можно установить и без фреймворка.\nQt Creator достаточно легковестный, а его графическая обертка вокруг отладчика gdb простая и удобная.\nЕсли не знаете, с чего начать - поробуйте его.\ngdb # Вариант для хардкорных красноглазиков.\nСобираете программу и запускаете отладчик\ngdb a.out Чтоб глазам было поприятнее включаете отображение кода\n(gdb) layout src и получаете вот такую красоту прямо в терминале\n┌─main.c────────────────────────────────────────────────────────────────────────────┐ │ 1 #include \u0026lt;stdio.h\u0026gt; │ │ 2 │ │ 3 │ │ 4 int main() { │ │ 5 int x = 123; │ │ 5 int y = 456; │ │ 5 printf(\u0026#34;%d\u0026#34;, x + y); │ │ 6 } │ │ 7 │ │ │ └───────────────────────────────────────────────────────────────────────────────────┘ (gdb) Чтоб поставить breakpoint - точку, на которой остановится выполнение - нужно ввести команду break или сокращенно - b\n(gdb) break main После этого можно запустить программу вбив run или же r\nТеперь можно выводить значения переменных используя print\nИ перемещаться используя step (s) и next (n)\nВот есть брошюрка с популярными командами\nНачните тыкаться - и быстро привыкните\nа если я не знаю где ошибка? # Справедливо. Проходить по шагам всю программу - немного жестоко)\nПри сборке можно включить дополнительные проверки в рантайме. Такие \u0026ldquo;штуки\u0026rdquo; называют санитайзеры.\n[danila@archlinux /tmp/foo] $ cat main.c #include \u0026lt;stdlib.h\u0026gt; int main() { int *buffer = malloc(20 * sizeof(int)); buffer[7] = 123; } [danila@archlinux /tmp/foo] $ gcc -fsanitize=address main.c [danila@archlinux /tmp/foo] $ ./a.out ================================================================= ==196147==ERROR: LeakSanitizer: detected memory leaks Direct leak of 80 byte(s) in 1 object(s) allocated from: #0 0x7781c2efd891 in malloc /usr/src/debug/gcc/gcc/libsanitizer/asan/asan_malloc_linux.cpp:69 #1 0x5db27deeb17a in main (/tmp/foo/a.out+0x117a) (BuildId: d0d4a2cf20f6bd1d9f1f1516816491c33dd0661a) #2 0x7781c2c34e07 (/usr/lib/libc.so.6+0x25e07) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #3 0x7781c2c34ecb in __libc_start_main (/usr/lib/libc.so.6+0x25ecb) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #4 0x5db27deeb094 in _start (/tmp/foo/a.out+0x1094) (BuildId: d0d4a2cf20f6bd1d9f1f1516816491c33dd0661a) SUMMARY: AddressSanitizer: 80 byte(s) leaked in 1 allocation(s) Окей, давайте добавим free\n[danila@archlinux /tmp/foo] $ cat main.c #include \u0026lt;stdlib.h\u0026gt; int main() { int *buffer = malloc(20 * sizeof(int)); free(buffer); buffer[7] = 123; } [danila@archlinux /tmp/foo] $ gcc -fsanitize=address main.c [danila@archlinux /tmp/foo] $ ./a.out ================================================================= ==197542==ERROR: AddressSanitizer: heap-use-after-free on address 0x50700000003c at pc 0x5dbbd5db31da bp 0x7ffc6c2130d0 sp 0x7ffc6c2130c0 WRITE of size 4 at 0x50700000003c thread T0 #0 0x5dbbd5db31d9 in main (/tmp/foo/a.out+0x11d9) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) #1 0x7b08df834e07 (/usr/lib/libc.so.6+0x25e07) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #2 0x7b08df834ecb in __libc_start_main (/usr/lib/libc.so.6+0x25ecb) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #3 0x5dbbd5db30a4 in _start (/tmp/foo/a.out+0x10a4) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) 0x50700000003c is located 28 bytes inside of 80-byte region [0x507000000020,0x507000000070) freed by thread T0 here: #0 0x7b08dfafc282 in free /usr/src/debug/gcc/gcc/libsanitizer/asan/asan_malloc_linux.cpp:52 #1 0x5dbbd5db319a in main (/tmp/foo/a.out+0x119a) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) #2 0x7b08df834e07 (/usr/lib/libc.so.6+0x25e07) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #3 0x7b08df834ecb in __libc_start_main (/usr/lib/libc.so.6+0x25ecb) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #4 0x5dbbd5db30a4 in _start (/tmp/foo/a.out+0x10a4) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) previously allocated by thread T0 here: #0 0x7b08dfafd891 in malloc /usr/src/debug/gcc/gcc/libsanitizer/asan/asan_malloc_linux.cpp:69 #1 0x5dbbd5db318a in main (/tmp/foo/a.out+0x118a) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) #2 0x7b08df834e07 (/usr/lib/libc.so.6+0x25e07) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #3 0x7b08df834ecb in __libc_start_main (/usr/lib/libc.so.6+0x25ecb) (BuildId: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3) #4 0x5dbbd5db30a4 in _start (/tmp/foo/a.out+0x10a4) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) SUMMARY: AddressSanitizer: heap-use-after-free (/tmp/foo/a.out+0x11d9) (BuildId: c59a69d40605b369ee77c6dd1e547b78afc81ec4) in main Shadow bytes around the buggy address: 0x506ffffffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x506ffffffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x506ffffffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x506fffffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x506fffffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =\u0026gt;0x507000000000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fa fa 0x507000000080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x507000000100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x507000000180: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x507000000200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x507000000280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb ==197542==ABORTING Красиво? Ага)\nПроверок довольно много. Каждая из них замедляет выполнение, но позволяет ловить всякие непотребства.\nСамые полезные для вас сейчас - address-санитайзер и memory-санитайзер. Развлекайтесь - собирайте задачки, запускайте тесты и т.д.\n"},{"id":7,"href":"/2024-caos-examples/docs/theory/devools/make/","title":"автоматизация сборки","section":"Инструменты разработки","content":" Автоматизация сборки # Ну а теперь, finally, про то, как собирать проекты!\nКак собирать проекты # Окей хорошо\u0026hellip; У меня есть куча файлов. Что с ними делать то?\nЧтоб была какая-нибудь конкретика, давайте определимся с проектом, который сделает вас супер богатым\n$ tree bitcoin_cracker bitcoin_cracker ├── encription.c ├── encription.h ├── hashlib.c ├── hashlib.h ├── main.c ├── small_math.c └── small_math.h При этом давайте допустим, что\nhashlib и encription оба используют small_math. main использует только hashlib и encription. Зависимости # В .h-файлах находятся объявления функций и констант. В .c содержатся их определения (да, взучит криво - гуглите \u0026ldquo;declaration vs definition\u0026rdquo;). Если нет - надо рефакторить. Такое го.. месиво собрать будет сложно\u0026hellip;\nДальше стоит проверить зависимости. Помните этапы сборки? Вплоть до этапа линковки мы собираем отдельно каждый файлик. Чуть честнее - мы собираем только .c-файлы, т.к. там содержатся определения функций. Желательно не инклудить один .c-файл в другой (поменьше #include \u0026lt;smth.c\u0026gt; пожалуйста). Это неочевидное поведение и bad-pattern.\nКратко правила хорошего тона для зависимостей:\nобъявления - в .h файлах реализация для somelibname.h - в somelibname.c строго говоря, никто не мешает разные функции из somelibname.h реализовывать в разных .c файлах; но не могу придумать, когда это полезно в .c файликах инклудьте только .h файлики в .h файлика инклудьте только .h файлики (а желательно - ничего) Наверное стоит сказать и про header-only библиотеки - это когда вы всю реализацию пишете в .h-файлик. Минусы очевидны, но если библиотека маленькая - то это вполне нормальная идея.\nДопустим что вы причесали зависимости и теперь они выглядят как-то так: graph LR; small_math.c --\u003e small_math.h hashlib.c --\u003e hashlib.h hashlib.c --\u003e small_math.h encription.c --\u003e encriptoin.h encription.c --\u003e small_math.h main.c --\u003e hashlib.h main.c --\u003e encription.h (стрелочка вида a --\u0026gt; b значит, что в a есть строчка #include \u0026lt;b\u0026gt;)\nСобираем все ручками # Нам нужно собрать три наши библиотеки и код программы в оъектные файлы. А потом натравить на это линкер.\nИ это даже будет работать\ngcc -c small_math.c gcc -c hashlib.c gcc -c encription.c gcc -c main.c gcc small_math.o hashlib.o encription.o main.o -o bitcoin_cracker Да, .h файлики не передаются gcc как параметры - они подставляются .c файлики препроцессором во время сборки.\n.sh или как не писать ручками # Первое что приходит на ум, когда не хочется писать все ручками - запихать всё в скрипт. Идея неплохая - давайте сделаем.\n$ cat \u0026gt; build_all.sh \u0026lt;\u0026lt;EOF #!/bin/bash gcc -c small_math.c gcc -c hashlib.c gcc -c encription.c gcc -c main.c gcc small_math.o hashlib.o encription.o main.o -o bitcoin_cracker EOF $ cat build_all.sh #!/bin/bash gcc -c small_math.c gcc -c hashlib.c gcc -c encription.c gcc -c main.c gcc small_math.o hashlib.o encription.o main.o -o bitcoin_cracker Про EOF как-нибудь потом (TODO: вставить ссылку). Про то, что такое #!/bin/bash тоже потом (TODO: вставить ту же ссылку).\nДальше надо дать файлику права на исполнение (TODO: вставить ссылку в третий раз)\nchmod +x build_all.sh Теперь скрипт можно запустить и собрать всё\n./build_all.sh make или как не пересобирать все каждый раз # Чем ручной процесс был лучше скрипта build_all.sh? Тем, что мы могли не пересобирать файлы, которые не менялись.\nВ Unix есть тулза для сборки, которая умеет следить за изменениями файлов и пересобирать только изменившиеся. Программа называется - make.\nmake обрабатывает блоки +-такого вида\nsmall_math.o: small_math.h small_math.c gcc -c small_math.c (там не 4 пробела, там таб \\t - это обязательно)\nsmall_math.o - это цель small_math.h и small_math.c - это зависимости gcc -c small_math.c - это инструкция, как из зависимостей собрать цель в роли инструкци может быть любая команда цель и зависимости - почти всегда являются файлами. Можно собрать отдельную цель выполнив make small_math.o. По умолчанию запуск make без аргументов равносилен make all (all - пример, когда цель не является файлом).\nВсе блоки с инструкциями помещаются в файл с названием Makefile. Makefile для нашего проекта будет какой-то такой\n$ cat Makefile all: small_math.o hashlib.o encription.o main.o gcc -o small_math.o hashlib.o encription.o main.o -o bitcoin_cracker main.o: main.c hashlib.h encription.h gcc -c main.c hashlib.o: hashlib.c hashlib.h gcc -c hashlib.c encription.o: encription.c encription.h gcc -c encription.c small_math.o: small_math.c small_math.h gcc -c small_math.c clean: rm -rf *.o bitcoin_cracker Ещё принято добавлять цель clean, чтоб при запуске make clean очищались артефакты сборки.\nПроргама make сама отслеживает обновления файлов и при запуске сборки (просто make) будет пересобирать только те цели, зависимости которых изменились.\nВ домашках для сборки и тестирования используется make\nА ещё в make есть переменные # Если вы собираете разными компиляторами или хотите однотипно настроить что-нибудь, то это будет проще сделать с помощью переменных\n$ cat Makefile COMPILER=gcc FLAGS=-ggdb OUTPUT=bitcoin_cracker all: small_math.o hashlib.o encription.o main.o ${COMPILER} ${FLAGS} -o small_math.o hashlib.o encription.o main.o -o ${OUTPUT} main.o: main.c hashlib.h encription.h ${COMPILER} ${FLAGS} -c main.c hashlib.o: hashlib.c hashlib.h ${COMPILER} ${FLAGS} -c hashlib.c encription.o: encription.c encription.h ${COMPILER} ${FLAGS} -c encription.c small_math.o: small_math.c small_math.h ${COMPILER} ${FLAGS} -c small_math.c clean: rm -rf *.o bitcoin_cracker Можно делать более крутые и полезные вещи, примеры есть вот тут.\ncmake или как генерировать Makefile # Можно бесконечно делать 3 вещи\nсмотреть, как горит огонь наблюдать, как течет вода и слушать, как разработчик жалуется на документацию cmake не то чтоб она прям очень плохая, страшная и неудобная\u0026hellip; просто она имеет бесконечный потенциал для оптимизации Но cmake решает сразу много важных проблем\nон позволяет собирать код разными компиляторами и на разных системах он позволяет использовать кросплатформенные библиотеки (OpenGL for example) он позволяет автоматически генерировать Makefile, а не прописывать всё ручками для больших проектов это прям спасение а ещё помимо Makefile, он умеет создавать проекты под разные IDE: Visual Studio / Xcode / CodeBlocks / \u0026hellip; использовать другие системы сборки: Ninja / \u0026hellip; запускать разные скрипты (вообще любые) и да, я тоже считаю, что это зло запускать тесты!) TODO: сделать пример для нашего проекта (можете пока почитать эту статью на хабре)\nТеперь его можно собрать\n# сейчас мы в директории, где лежит CmakeLists.txt $ mkdir build $ cd build $ cmake .. # тут куча текста $ make gcc -c small_math.c gcc -c hashlib.c gcc -c encription.c gcc -c main.c gcc small_math.o hashlib.o encription.o main.o -o bitcoin_cracker Слава OpenSource! # Слышали ли вы когда-нибудь про aseprite?\nЭто тулза для создания pixel-art рисунков и анимаций. Так получилось, что она распространяется под достаточно свободной лицензией (вероятнее всего из-за того, что одна из её библиотек распространяется под GPL-like лицензией) Поэтому её исходники лежат на гитхабе))\nЭто не проблема, т.к. художники не умеют собирать код из исходников, а программисты не умеют рисовать\u0026hellip;\nЛистаем в самый низ сайта и в колонке Development находим ссылку на GitHub. В корне видем уже знакомый нам CMakeLists.txt. Скачиваем проект себе локально и колдуем заклинание сборки\n$ mkdir build $ cd build $ cmake .. # .... $ make # ... Сборка займет порядочно времени, но как итог - вы бесплатно (и легально!) получили рисовалку, которая продается почти за 20$)\n"},{"id":8,"href":"/2024-caos-examples/docs/theory/x86_64/floats/","title":"floats","section":"x86_64 assembler","content":" Floats # В курсе не рассматриваются команды для старого FPU (который fmov, fadd \u0026hellip;), поэтому мы его тоже скипнем.\nРаньше особого смысла в обработке дробных чисел на офисных машинках не было. (тем более что деньги так считать нельзя).\nПоэтому FPU (Floating point Processing Unit) стал поставлятся не сразу, а в начале вообще был отдельным \u0026ldquo;камнем\u0026rdquo;.\nСейчас это просто один из модулей центрального процессора.\nSSE (Streaming SIMD Extensions) # В x86_64 есть большие регистры, через которые можно работать с числами с плавающей точкой.\nxmm0, xmm1, \u0026hellip; xmm15 - 128bit регистры Ну и дальше снова понесло\nymm1, ymm2, \u0026hellip; ymm15 - 256bit регистры (нижняя половина совпадает с xmmN) zmm1, zmm2, \u0026hellip; zmm15 - 512bit регистры (нижняя половина совпадает с ymmN) zmmN поддерживаются не везде и используются не всеми (так что в домашках можете на них забить).\nДля работы с SSE регистрами есть свой набор команд.\nJust floats (doubles) # Давайте пока забудем про размер в 128bit и про SIMD в SSE и поговорим просто про работу с \u0026ldquo;одним\u0026rdquo; числом.\nsingle single VS single double # Пока будем смотреть только на суффиксы sd и ss\nmovss DST, SRC // | |`- Single - aka float // | `- Single - работаем с одним числом // `----- mov - операнд movsd DST, SRC // | |`- Double - aka double // | `- Single - работаем с одним числом // `----- mov - операнд Т.е. при работе, например, с xmm0 при загрузке из памяти movss заполнит только младшие 32bit регистра.\nарифметические операции # Ну тут все просто - ловите таблицу\naddsd DST, SRC // DST += SRC, double addss DST, SRC // DST += SRC, float subsd DST, SRC // DST -= SRC, double subss DST, SRC // DST -= SRC, float mulsd DST, SRC // DST *= SRC, double mulss DST, SRC // DST *= SRC, float divsd DST, SRC // DST /= SRC, double divss DST, SRC // DST /= SRC, float sqrtsd DST, SRC // DST = sqrt(SRC), double sqrtss DST, SRC // DST = sqrt(SRC), float maxsd DST, SRC // DST = max(DST, SRC), double maxss DST, SRC // DST = max(DST, SRC), float minsd DST, SRC // DST = min(DST, SRC), double minss DST, SRC // DST = min(DST, SRC), float Добавилась пара новых команд (min, max, sqrt). И есть деление на float и double, которые разобрали выше.\nЕщё две группы команд (не арифметика, но +-рядом) - преобразование в int и обратно\ncvtsd2si DST, SRC // double -\u0026gt; int cvtsi2sd DST, SRC // int -\u0026gt; double (для float додумайте сами)))\nИ отдельно сравнение\ncomisd DST, SRC // для double comiss DST, SRC // для float Про сравнение float-ов # Наверное вам говорили, что проверять равенство float-ов напрямую нельзя, а нужно сравнивать модуль разности. Это не совсем так. Одинаковые арифметические действия дадут одинаковый результат. Поэтому сравнение float-ов используя == не лишено смысла.\nНо если вы приближенно считаете что-нибудь как-то так\nfloat current_value = ...; float prev_value = ...; // --- // while (current_value != prev_value) { float new_value = do_next_iteration(prev_value, current_value); prev_value = current_value; current_value = prev_value; } то вы сравниваете так зря) Классический пример с прибавлением 0.01 в цикле for, пока не получим 1 тоже никто не отменял. Если последовательность сходится к X на N-ом шаге, это не значит, что вы получите X\nА ещё иногда всплявают подводные камни, дают вам пару пинков и уходят обратно. В \u0026ldquo;старом\u0026rdquo; FPU регистры для работы с float-ами были(да и есть) внимание! 80bit (SSE регистры появились сильно позже). Из этого следует, что их невозможно без потерь сохранить в 64bit-а. Отсюда получаем один из самых древних и болючих багов в gcc (не думали же вы, что там багов нет?)) - баг 323. Кому интересно - вот статья на habr.\nSIMD # Время параллелить! Время использовать все 128bit xmm0!\nРазмер float - 32bit, а double - 64bit. Путём несложных рассчетов получаем, что в xmm0 влазит 4 float или 2 double. И вот как раз с этими числами можно работать параллельно.\nДля такой работы вместо single (выше) используется packed.\nРабота с памятью # Снова куча страшных суфиксов\nmov[ap|up][s|d] DST, SRC выравнивание по 16bit ap - Aligned Packed up - Unaligned Packed (выравнивания нет) float / double s - Single aka float d - Double aka double Команды с выравниванием работают быстрее. И компилятор (при выделении памяти под массивы) следит за выравниванием.\nАрифметика # Тут все чуть проще\nOPERATION[p][s|d] p - Packed float / double s - Single aka float d - Double aka double Ну т.е. mulpd xmm0, xmm1 - это мы попарно перемножаем double-ы в xmm0 и xmm1 и сохраняем результат в xmm0\nHorizontal add # Окей\u0026hellip; А что если я хочу 2 double (4 float) сложить внутри одного регистра?\nНу как минимум есть hadd[p][s|d] - aka Horizontal ADD Packed и дальше float / double. Вот так будет выглядеть haddps xmm0, xmm1 Команду можно применять саму на себя - haddps xmm0, xmm0 будет валидной командой.\nShuffle # И совсем жуткая жуть - shufps (и shufpd)\nshufpd xmm0, xmm1, 11100100b Выполняет перестановĸу элементов из исходных регистров и записывает в регистр назначения. Перестановка задается числом (байтом) - третий аргумент. В бинарном виде удобнее.\n+-все бъяснения страшные (это плохо).\nВ домашках вам не встретится (это хорошо).\nНа лекции было хорошее объяснение, поэтому я его позаимствую)) На псевдокоде будет как-то так\nshufps xmm0, xmm1, #mask /* Каждая пара бит задаёт число от 0 до 3. * Это id ячейки (числа), которое нужно выбрать */ XMM0[0] = select(XMM0, (mask \u0026amp; 0b00000011) \u0026gt;\u0026gt; 0) XMM0[1] = select(XMM0, (mask \u0026amp; 0b00001100) \u0026gt;\u0026gt; 2) XMM0[2] = select(XMM1, (mask \u0026amp; 0b00110000) \u0026gt;\u0026gt; 4) XMM0[3] = select(XMM1, (mask \u0026amp; 0b11000000) \u0026gt;\u0026gt; 6) select(XMM, idx) { return XMM[idx] } "},{"id":9,"href":"/2024-caos-examples/docs/theory/x86_64/","title":"x86_64 assembler","section":"Как закрыть курс","content":" x86_64 assembler # "},{"id":10,"href":"/2024-caos-examples/docs/theory/arm/","title":"ARM assembler","section":"Как закрыть курс","content":" ARM assembler # В основном тут будут отличия x86_64 от ARM.\nИ во многом будет дублировать лекцию.\nCISC vs RISC # RISC # Restricted Instruction Set Computer\nSmall number of fixed length instructions\nSimple, standart instructions\nRead-Modify-Wright way\nHeavy use of RAM\nCISC # Complex Instruction Set Computer\nLarge number of instructions\nComplex, variable-length instructions\nMore efficient use of RAM\nВ целом (за парой оговорками), можно считать, что x86_64 это CISC, а ARM это RISC.\nЕсли кто-то вдруг вспомнил про Эльбрус, то там VLIW (Very Large Instruction Word). Одной инструкцией даётся команда на все ядра (вроде). Там свои плюсы / минусы и вообще своя атмосфера. Про него в курсе не будет, хотя чисто архитектурно штука интересная.\nARM регистры # x0, x1, x2, \u0026hellip; x30 - 64bit w0, w1, w2, \u0026hellip; w30 - 32bit (вложены в xN) есть регистр в котором всегда 0 - xzr (wzr) дальше чуть привычнее\nsp - aka Stack Pointer pc - aka Instruction Pointer (мастер аббревиатур) основные команды # mov уже должны помнить) mov reg1 reg2 mov reg1 =123 str{type} Xn [Xs] сохраняет данные из регистра Xn по адресу Xs {type} указывает на размер является необязательным без {type} сохранит регистр целиком b - unsigned byte sb - signed byte h - half (16 bits) - т.к. машинное слово - 32bits sh - signed half регистров меньше 32bit нету - отсюда нужны именно такие суффиксы ldr{type} Xn =label загружает данные в регистр Xn из памяти по метке label {type} - необязателен; использование аналогично str ldr{type} Xn [Xs] загружает данные в регистр Xn из памяти по адресу Xs {type} - необязателен; использование аналогично str ARM conditionals # В x86_64 единственным способом добавить нелинейности в программу были jmp (ну и всякие jne, jle, \u0026hellip;)\nВ ARM суффиксы можно добавить к большинству инструкций. В регистре флагов pstate есть флаги n - negative, z - zero, c - carry, v - overflow (г - лоГгика).\nСуффиксы в x86_64 и ARM отличаются (не силно но отличаются)\nEQ\tEqual NE\tNot equal CS\tCarry set (identical to HS) HS\tUnsigned higher or same (identical to CS) CC\tCarry clear (identical to LO) LO\tUnsigned lower (identical to CC) MI\tMinus or negative result PL\tPositive or zero result VS\tOverflow VC\tNo overflow HI\tUnsigned higher LS\tUnsigned lower or same GE\tSigned greater than or equal LT\tSigned less than GT\tSigned greater than LE\tSigned less than or equal AL\tAlways (this is the default) Если такая команда выполняется всегда\nmov x0, x1 То вот такая уже в зависимости от pstate\nmovne x0, x1 Отличия в самом синтаксисе # Вообще говоря в ARM у арифметических команд целых 3 параметра\nadd Xd, Xn, Xm Это простое и лаконичное Xd = Xn + Xm\nПри этом центральный аргумент может дублировать левый\nadd Xd, Xd, Xm Всё правильно - Xd = Xd + Xm\nПри этом в GAS есть синтаксический сахар - если первый и второй аргументы совпадают, то второй аргумент можно опустить\nadd Xd, Xm RMW flow # Read-Modify-Write очень прост - читаем, что-то делаем, сохраняем (thx cap)\nВот так можно загружать из памяти\nldr Xt, [Xn, offset] ; Xt = *(Xn + offset), offset \\in [-256, 16384) ldr Xt, [Xn] ; Xt = *Xn ldr Xt, =label ; Xt = *label ldr Xt, [Xn, Xm] ; Xt = *(Xn + Xm) ldr Xt, [Xn, Xm, LSL n] ; Xt = *(Xn + (Xm \u0026lt;\u0026lt; n)) = *(Xn + Xm * (2 ** n)), n = 1/2/3/4/8 Ветвление # Вместо jmp тут b (aka branch)\nbeq label ; Branch to label if equal (z = 1) bne label ; Branch to label if not equal (z = 0) blt label ; Branch to label if less than (n != v) ble label ; Branch to label if less or equal (z = 1 or n != v) bgt label ; Branch to label if greater than (z = 0 and n == v) bge label ; Branch to label if greater or equal (n == v) Вызов функций # ret существует\ncall не существует - вместо него bl (aka Branch with Link). bl кладет адрес возврата не на стек, а в x30.\nЕсли хотите вызвать что-то ещё - кладите x30 на стек ручками (push + pop).\nЗа счет этого получаем почти бесплатные (по сравнению с x86_64) вызовы малых функций.\nCalling convention # x0..x7 - аргументы (и в x0 - возвращаемое значение) x19..x28 - callee-saved registers (вы их должны сохранить) "},{"id":11,"href":"/2024-caos-examples/docs/theory/arm/linaro/","title":"Linaro (а как тестить)","section":"ARM assembler","content":" Linaro (а как мне это запустить то???) # Если у вас есть MacBook на ARM или Raspberry Pi / другой китайский одноплатник, то можете писать на нём.\nЭта страничка необходима только людям с компами на intel.\nCross compilation # У нас компы на intel (x86_64), а код написан под ARM. Чтоб собирать под другую (относительно нашей системы) архитектуру, нужен другой компилятор.\nстандартные пакеты # I use Arch btw так что за Ubuntu не очень шарю, но кажется можно просто поставить\nsudo apt-get update sudo apt-get install gcc-13-aarch64-linux-gnu После этого должен появиться компилятор aarch64-linux-gnu-gcc. Если да, то gcc-linaro можете пропустить\ngcc-linaro # Есть проект Linaro, можно позаимствовать компилятор у них. У них есть toolchain, можно взять последний gcc-7.\nКачаем компилятор (gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz) и sysroot (sysroot-glibc-linaro-2.25-2019.12-aarch64-linux-gnu.tar.xz). Про sysroot чуть позже\nПосле скачивания разархивируем оба архива (tar xvf; а вообще tldr tar вам подскажет). Самое полезное сейчас лежит вот тут\n$ ls gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin aarch64-linux-gnu-addr2line aarch64-linux-gnu-gcov-tool aarch64-linux-gnu-ar\taarch64-linux-gnu-gdb aarch64-linux-gnu-as\taarch64-linux-gnu-gdb-add-index aarch64-linux-gnu-c++\taarch64-linux-gnu-gfortran aarch64-linux-gnu-c++filt aarch64-linux-gnu-gprof aarch64-linux-gnu-cpp\taarch64-linux-gnu-ld aarch64-linux-gnu-dwp\taarch64-linux-gnu-ld.bfd aarch64-linux-gnu-elfedit aarch64-linux-gnu-ld.gold aarch64-linux-gnu-g++\taarch64-linux-gnu-nm aarch64-linux-gnu-gcc\taarch64-linux-gnu-objcopy aarch64-linux-gnu-gcc-7.5.0 aarch64-linux-gnu-objdump aarch64-linux-gnu-gcc-ar aarch64-linux-gnu-ranlib aarch64-linux-gnu-gcc-nm aarch64-linux-gnu-readelf aarch64-linux-gnu-gcc-ranlib aarch64-linux-gnu-size aarch64-linux-gnu-gcov\taarch64-linux-gnu-strings aarch64-linux-gnu-gcov-dump aarch64-linux-gnu-strip Чтоб при запуске не прописывать пути целиком можно прописать\nexport PATH=$PATH:/home/danila/linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin (очевидно нужно прописать правильный путь до папки)\nПосле этого (в том же терминале) должна отрабатывать команда\n$ aarch64-linux-gnu-gcc -v Using built-in specs. COLLECT_GCC=aarch64-linux-gnu-gcc COLLECT_LTO_WRAPPER=/home/danila/linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/../libexec/gcc/aarch64-linux-gnu/7.5.0/lto-wrapper Target: aarch64-linux-gnu Configured with: \u0026#39;/home/tcwg-buildslave/workspace/tcwg-make-release_0/snapshots/gcc.git~linaro-7.5-2019.12/configure\u0026#39; SHELL=/bin/bash --with-mpc=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-mpfr=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gmp=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gnu-as --with-gnu-ld --disable-libmudflap --enable-lto --enable-shared --without-included-gettext --enable-nls --with-system-zlib --disable-sjlj-exceptions --enable-gnu-unique-object --enable-linker-build-id --disable-libstdcxx-pch --enable-c99 --enable-clocale=gnu --enable-libstdcxx-debug --enable-long-long --with-cloog=no --with-ppl=no --with-isl=no --disable-multilib --enable-fix-cortex-a53-835769 --enable-fix-cortex-a53-843419 --with-arch=armv8-a --enable-threads=posix --enable-multiarch --enable-libstdcxx-time=yes --enable-gnu-indirect-function --with-build-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/sysroots/aarch64-linux-gnu --with-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu/aarch64-linux-gnu/libc --enable-checking=release --disable-bootstrap --enable-languages=c,c++,fortran,lto --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux-gnu --target=aarch64-linux-gnu --prefix=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu Thread model: posix gcc version 7.5.0 (Linaro GCC 7.5-2019.12) Теперь нужно проверить, что всё работает\nhello-world #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello, arm!\\n\u0026#34;); return 0; } Собираем\naarch64-linux-gnu-gcc main.c И потом пробуем дизассемблировать. Наш objdump знать ничего не знает про ARM. Поэтому запускаем бинарник от linaro.\naarch64-linux-gnu-objdump -d a.out многа букав Стоит обратить внимание на стройные ряды op-кодов (либо 2 байта, либо 4 байта).\nQEMU # Запускать код на арм мы тоже не можем. Поэтому нужен эмулятор.\nСтавим qemu\nsudo apt-get install qemu-system-arm Но просто так запустить не получится - требуются динамические библиотеки. Они идут просто набором файликов. Папку с ними буду называть sysroot. Тут буду показывать вариант с linaro (архив sysroot-glibc-linaro-2.25-2019.12-aarch64-linux-gnu.tar.xz).\nа почему sysroot? Потому что там дерево файликов linux-а))) Но только с arm-библиотеками.\n$ ls sysroot-glibc-linaro-2.25-2019.12-aarch64-linux-gnu.tar.xz/ etc lib sbin\tusr var Запускаем qemu и через флаг -L передаем наш sysroot.\n$ qemu-aarch64 -L ~/linaro/sysroot-glibc-linaro-2.25-2019.12-aarch64-linux-gnu/ ./a.out hello, arm! Ещё пара костылей # Есть шанс, что у вас не будут локально работать тесты. Если вы справились собрать hello-world и запустить его под qemu, но не собирается или (и) не запускаются тесты - то надо править Makefile\nТам будет что-то +-такое\n$ cat Makefile all: test_simple simple: test_simple/test_simple.c add.s aarch64-linux-gnu-gcc test_simple/test_simple.c add.s -o $@ test_simple: input_simple/input_simple.txt simple qemu-aarch64 -L /usr/aarch64-linux-gnu ./simple .PHONY: all test_simple Нужно\nзаменить aarch64-linux-gnu-gcc на нужное название компилятора или на путь до компилятора если длинно/страшно/уродливо - вынесите в переменную заменить -L /usr/aarch64-linux-gnu на путь до sysroot-glibc-linaro-2.25-2019.12-aarch64-linux-gnu если длинно/страшно/уродливо - вынесите в переменную "}]